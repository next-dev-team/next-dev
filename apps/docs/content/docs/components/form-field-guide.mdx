---
title: Form Field Components
description: Comprehensive guide to form field components using rc-field-form with React Native.
---

import { 
  FormBasicPreview, 
  FormFieldTypesPreview, 
  FormCustomValidationPreview, 
  FormDynamicFieldsPreview 
} from '@docs/components/examples';

<ExternalLinks
  links={[
    { title: 'rc-field-form GitHub', url: 'https://github.com/react-component/field-form' },
    { title: 'rc-field-form API Reference', url: 'https://github.com/react-component/field-form#api' },
  ]}
/>

<div className="h-5" />

## Overview

This guide covers the comprehensive usage of form field components built with `rc-field-form` for React Native applications. The form system provides powerful validation, field management, and state handling capabilities.

## Core Concepts

### Field Names

Field names support dot notation for nested objects and arrays:

```tsx
// Simple field
<Form.Item name="username">
  <TextInput />
</Form.Item>

// Nested object
<Form.Item name="user.email">
  <TextInput />
</Form.Item>

// Array field
<Form.Item name={['emails', index]}>
  <TextInput />
</Form.Item>
```

### Validation Rules

The form supports multiple validation rule types:

```tsx
<Form.Item
  name="email"
  rules={[
    { required: true, message: 'Email is required' },
    { type: 'email', message: 'Please enter a valid email' },
    { min: 5, message: 'Email must be at least 5 characters' },
    { max: 50, message: 'Email must be less than 50 characters' },
    { pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/, message: 'Invalid email format' },
    { validator: customValidator },
  ]}
>
  <TextInput placeholder="Enter email" />
</Form.Item>
```

### Custom Validators

Create custom validation functions for complex business logic:

```tsx
const validatePassword = async (_: any, value: string) => {
  if (!value) {
    return Promise.reject(new Error('Password is required'));
  }
  
  if (value.length < 8) {
    return Promise.reject(new Error('Password must be at least 8 characters'));
  }
  
  // Check for complexity
  const hasUpperCase = /[A-Z]/.test(value);
  const hasLowerCase = /[a-z]/.test(value);
  const hasNumbers = /\d/.test(value);
  const hasSpecialChar = /[!@#$%^&*]/.test(value);
  
  if (!hasUpperCase || !hasLowerCase || !hasNumbers || !hasSpecialChar) {
    return Promise.reject(new Error('Password must contain uppercase, lowercase, numbers, and special characters'));
  }
  
  return Promise.resolve();
};
```

## Field Types Example

<Tabs defaultValue="preview">
  <TabsList>
    <TabsTrigger value="preview">Preview</TabsTrigger>
    <TabsTrigger value="code">Code</TabsTrigger>
  </TabsList>
  <TabsContent value="preview">
    <PreviewCard preview={<FormFieldTypesPreview />} />
  </TabsContent>
  <TabsContent value="code">
    ```json doc-gen:file
    {
      "file": "./node_modules/@rnr/rnr-ui/src/examples/form/form-field-types.tsx",
      "codeblock": {
        "lang": "tsx"
      }
    }
    ```
  </TabsContent>
</Tabs>

## Custom Validation Example

<Tabs defaultValue="preview">
  <TabsList>
    <TabsTrigger value="preview">Preview</TabsTrigger>
    <TabsTrigger value="code">Code</TabsTrigger>
  </TabsList>
  <TabsContent value="preview">
    <PreviewCard preview={<FormCustomValidationPreview />} />
  </TabsContent>
  <TabsContent value="code">
    ```json doc-gen:file
    {
      "file": "./node_modules/@rnr/rnr-ui/src/examples/form/form-custom-validation.tsx",
      "codeblock": {
        "lang": "tsx"
      }
    }
    ```
  </TabsContent>
</Tabs>

## Dynamic Fields Example

<Tabs defaultValue="preview">
  <TabsList>
    <TabsTrigger value="preview">Preview</TabsTrigger>
    <TabsTrigger value="code">Code</TabsTrigger>
  </TabsList>
  <TabsContent value="preview">
    <PreviewCard preview={<FormDynamicFieldsPreview />} />
  </TabsContent>
  <TabsContent value="code">
    ```json doc-gen:file
    {
      "file": "./node_modules/@rnr/rnr-ui/src/examples/form/form-dynamic-fields.tsx",
      "codeblock": {
        "lang": "tsx"
      }
    }
    ```
  </TabsContent>
</Tabs>

## Form Methods

### useForm Hook

The `useForm` hook provides access to form methods:

```tsx
const [form] = Form.useForm();

// Form instance methods
form.submit();                    // Submit the form
form.resetFields();               // Reset all fields
form.setFieldsValue(values);      // Set multiple field values
form.getFieldValue(name);         // Get single field value
form.getFieldsValue();            // Get all field values
form.validateFields();            // Validate all fields
form.setFields([{ name, errors: ['Error message'] }]); // Set field errors
```

### Form.Item Methods

```tsx
// Watch field changes
const username = Form.useWatch('username', form);

// Watch multiple fields
const [username, email] = Form.useWatch(['username', 'email'], form);

// Watch all fields
const allValues = Form.useWatch([], form);
```

## Advanced Patterns

### Field Dependencies

Make fields depend on other field values:

```tsx
<Form.Item
  name="country"
  label="Country"
  rules={[{ required: true }]}
>
  <TextInput placeholder="Enter country" />
</Form.Item>

<Form.Item
  name="postalCode"
  label="Postal Code"
  dependencies={['country']}
  rules={[
    { required: true },
    ({ getFieldValue }) => ({
      validator(_, value) {
        const country = getFieldValue('country');
        
        if (country === 'USA') {
          return /^\d{5}(-\d{4})?$/.test(value) 
            ? Promise.resolve() 
            : Promise.reject(new Error('Invalid US ZIP code'));
        }
        
        if (country === 'Canada') {
          return /^[A-Z]\d[A-Z] \d[A-Z]\d$/.test(value) 
            ? Promise.resolve() 
            : Promise.reject(new Error('Invalid Canadian postal code'));
        }
        
        return Promise.resolve();
      },
    }),
  ]}
>
  <TextInput placeholder="Enter postal code" />
</Form.Item>
```

### Async Validation

Implement server-side validation:

```tsx
const checkUsernameAvailability = async (username: string) => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Simulate taken usernames
  const takenUsernames = ['admin', 'user', 'test'];
  
  if (takenUsernames.includes(username.toLowerCase())) {
    throw new Error('Username is already taken');
  }
  
  return true;
};

<Form.Item
  name="username"
  label="Username"
  rules={[
    { required: true },
    {
      validator: async (_, value) => {
        if (!value) return Promise.resolve();
        
        try {
          await checkUsernameAvailability(value);
          return Promise.resolve();
        } catch (error) {
          return Promise.reject(error);
        }
      },
    },
  ]}
  validateTrigger="onBlur" // Validate on blur to avoid excessive API calls
>
  <TextInput placeholder="Choose username" />
</Form.Item>
```

### Dynamic Field Management

Add and remove fields dynamically:

```tsx
const [emails, setEmails] = useState(['']);

const addEmail = () => {
  setEmails([...emails, '']);
};

const removeEmail = (index: number) => {
  const newEmails = emails.filter((_, i) => i !== index);
  setEmails(newEmails);
  
  // Update form values
  const currentEmails = form.getFieldValue('emails') || [];
  const updatedEmails = currentEmails.filter((_: any, i: number) => i !== index);
  form.setFieldsValue({ emails: updatedEmails });
};

// Render dynamic fields
{emails.map((_, index) => (
  <View key={index} className="flex-row items-center mb-2">
    <Form.Item
      name={['emails', index]}
      rules={[{ required: true, type: 'email' }]}
      className="flex-1 mr-2"
    >
      <TextInput placeholder={`Email ${index + 1}`} />
    </Form.Item>
    
    {emails.length > 1 && (
      <Button onPress={() => removeEmail(index)} variant="destructive">
        Remove
      </Button>
    )}
  </View>
))}
```

## Best Practices

### 1. Validation Timing

- Use `validateTrigger="onBlur"` for async validation to avoid excessive API calls
- Use `validateTrigger="onChange"` for simple client-side validation
- Use `validateTrigger="onSubmit"` for complex validation that should only run on form submission

### 2. Error Handling

```tsx
// Set custom errors
form.setFields([
  { name: 'username', errors: ['Username is already taken'] },
  { name: 'email', errors: ['Invalid email format'] },
]);

// Clear specific field errors
form.setFields([{ name: 'username', errors: [] }]);

// Clear all errors
form.setFields([]);
```

### 3. Performance Optimization

```tsx
// Use shouldUpdate to control re-renders
<Form.Item shouldUpdate={(prevValues, currentValues) => 
  prevValues.country !== currentValues.country
}>
  {({ getFieldValue }) => {
    const country = getFieldValue('country');
    return country === 'USA' ? (
      <Form.Item name="state" rules={[{ required: true }]}>
        <TextInput placeholder="Enter state" />
      </Form.Item>
    ) : null;
  }}
</Form.Item>
```

### 4. TypeScript Integration

```tsx
interface FormValues {
  username: string;
  email: string;
  password: string;
  profile: {
    firstName: string;
    lastName: string;
    age: number;
  };
  emails: string[];
}

const [form] = Form.useForm<FormValues>();

// Type-safe form methods
form.setFieldsValue({
  username: 'john_doe',
  email: 'john@example.com',
  profile: {
    firstName: 'John',
    lastName: 'Doe',
    age: 25,
  },
  emails: ['john@example.com', 'john.work@example.com'],
});
```

## Common Patterns

### Login Form

```tsx
<Form form={form} onFinish={handleLogin}>
  <Form.Item
    name="email"
    label="Email"
    rules={[
      { required: true, message: 'Email is required' },
      { type: 'email', message: 'Please enter a valid email' },
    ]}
  >
    <TextInput
      placeholder="Enter your email"
      keyboardType="email-address"
      autoCapitalize="none"
    />
  </Form.Item>
  
  <Form.Item
    name="password"
    label="Password"
    rules={[{ required: true, message: 'Password is required' }]}
  >
    <TextInput
      placeholder="Enter your password"
      secureTextEntry
    />
  </Form.Item>
  
  <Button onPress={() => form.submit()}>
    Login
  </Button>
</Form>
```

### Registration Form with Password Confirmation

```tsx
const validateConfirmPassword = async (_: any, value: string) => {
  if (!value) {
    return Promise.reject(new Error('Please confirm your password'));
  }
  
  const password = form.getFieldValue('password');
  if (value !== password) {
    return Promise.reject(new Error('Passwords do not match'));
  }
  
  return Promise.resolve();
};

<Form.Item
  name="confirmPassword"
  label="Confirm Password"
  dependencies={['password']}
  rules={[{ validator: validateConfirmPassword }]}
>
  <TextInput
    placeholder="Confirm your password"
    secureTextEntry
  />
</Form.Item>
```

### Contact Form with Multiple Field Types

```tsx
<Form form={form} onFinish={handleSubmit}>
  <Form.Item
    name="fullName"
    label="Full Name"
    rules={[{ required: true }]}
  >
    <TextInput placeholder="Enter your full name" />
  </Form.Item>
  
  <Form.Item
    name="email"
    label="Email"
    rules={[{ required: true, type: 'email' }]}
  >
    <TextInput
      placeholder="Enter your email"
      keyboardType="email-address"
    />
  </Form.Item>
  
  <Form.Item
    name="phone"
    label="Phone Number"
    rules={[{ pattern: /^\d{10}$/, message: 'Please enter a valid 10-digit phone number' }]}
  >
    <TextInput
      placeholder="Enter phone number"
      keyboardType="phone-pad"
    />
  </Form.Item>
  
  <Form.Item
    name="message"
    label="Message"
    rules={[{ required: true, max: 500 }]}
  >
    <TextInput
      placeholder="Enter your message"
      multiline
      numberOfLines={4}
    />
  </Form.Item>
  
  <Button onPress={() => form.submit()}>
    Send Message
  </Button>
</Form>
```

## Troubleshooting

### Common Issues

1. **Fields not updating**: Ensure you're using the correct field name format
2. **Validation not triggering**: Check `validateTrigger` prop and field dependencies
3. **Async validation hanging**: Always return a Promise from custom validators
4. **Dynamic fields losing state**: Properly manage field arrays and update form values

### Debug Tips

```tsx
// Log form values on change
<Form.Item shouldUpdate>
  {({ getFieldsValue }) => {
    console.log('Form values:', getFieldsValue());
    return null;
  }}
</Form.Item>

// Check field errors
<Form.Item shouldUpdate>
  {({ getFieldError }) => {
    const errors = getFieldError('username');
    console.log('Username errors:', errors);
    return null;
  }}
</Form.Item>
```